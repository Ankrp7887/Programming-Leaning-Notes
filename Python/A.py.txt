Guido van Rossum (Netherlands as a successor to 'ABC programming language')
		Python 0.9.0 in 1991's
		Python 2.0 in 2000's|discontinued with version 2.7.18 in 2020's
		Python 3.0 in 2008's 


*To Compile & Run Python Program -->
Exicute these in terminal of working directory...
python3 file_name.py										python3 hello.py
	SourceCode -> Compiler -> ByteCode -> Interpreter(Python Vertual Machine) -> Machine language
	
> python is Interpreted language, 
	i.e. it gets exicuted line by line, unlike C/C++ which first compiled(get converted into bytecode) then get executed...	

SPECIAL VARIABLE--
	-> Used to run default code only from current module
__name__		# __name__ = '__main__' for static point of exicution for current working module
				# For imported module __name__ holds 'module_name' as static point of exicution from which it accessed...



**DATA TYPES--
	None
	boolean			var = True	, 	var = False
	int/float		var = 34	,	var = 3.45
	string			str1 = 'a' 	, 	str = 'ank'				#String is immutable(unable to modify once defined). But
					str2 = "Ankit"										partially accessible using indexing. eg, str[0] is 'A' 
					str3 = '''as			,str = """as							& str3[-1] is 't' & str3[1:-1] is 'nki' & str3[-4:-2] is 'nk'
							you know'''          you know"""
					str4 = str1 + str2 + " Patil"				# str4 = "aAnkit Patil"
					str5 = str1 * 5								# str5 = "aaaaa"		
	list			lst = ['Ank', ["A", 10]]					# lst[0] is 'Ank'  ||  lst[1] is ["A", 10]  ||  lst[1][0] is "A"
																# every element is pointer-object of list class, 
																  which results in more space/time complexity for woking on python lists, for efficiency we use Numpy arrays as it uses C/C++ arrays
	tuple			tpl = ('Ank', "A", 10)						# immutable
	set				x = {1,2,3,3,2} ->becomes-> {1,2,3}			# mutable & duplicates get removed || x=frozenset({'a',2}) is immutable
	directory		dict = {'key':"value", 12:21}				# values are accessed through keys || keys must be unique
	complex
	indentation		"	" -> denotes block of code	
	class		

**List Operation
	list = []
	list[i:j]  # returns list subset
	list[-1]   # returns last element
	list[:-1]  # returns all but the last element
	*list      # expands all elements in place  for; a=[1,2,3,4] | *a gives four distinct values *a= 1 2 3 4

	list[i] = val
	list[i:j] = otherlist  # replace ith to jth-1 elements with otherlist
	del list[i:j]

	list.append(item)
	list.extend(another_list)
	list.insert(index, item)
	list.pop()        # returns and removes last element from the list
	list.pop(i)       # returns and removes i-th element from the list
	list.remove(x)    # removes the first item from the list whose value is x
	list1 + list2     # combine two list    
	set(list)         # remove duplicate elements from a list

	list.reverse()    # reverses the elements of the list in-place
	list.count(item)
	sum(list)

	zip(list1, list2)  # returns list of tuples with n-th element of both list1 and list2
	list.sort()        # sorts in-place, returns None
	sorted(list)       # returns sorted copy of list
	",".join(list)     # returns a string with list elements seperated by comma

**Dictionary operation
	dict = {}
	dict.keys()
	dict.values()
	"key" in dict    # let's say this returns False, then...
		dict["key"]      # ...this raises KeyError
		dict.get("key")  # ...this returns None
	dict.setdefault("key", 1)
	**dict           # expands all k/v pairs in place


**ACCORDING TO ASCII
	"A" = 65			ord("A")
	"a" = 97			ord('a')


**OPERATORS--(with precedence)
		Operators in the same box have the same precedence
		Operators in the same box group left to right
		comparisons, membership tests, and identity tests, all have the same precedence and have a left-to-right chaining


	|***	OPERATORS(with precedence)							|	***		DESCRIPTION

	|(expressions...), [expressions...],						|	Binding or parenthesized expression, list display,
	|{key: value...}, {expressions...}							|	dictionary display, set display

	|x[index], x[index:index],									|	Subscription, slicing,
	|x(arguments...), x.attribute								|	call, attribute reference

	|await x													|	Await expression
	|**															|	Exponentiation 
	|+x, -x, ~x													|	Positive, negative, bitwise NOT
	|*, @, /, //, %												|	Multiplication, matrix multiplication, division, floor division, remainder 
	|+, -														|	Addition and subtraction
	|<<, >>														|	Shifts
	|&															|	Bitwise AND
	|^															|	Bitwise XOR
	||															|	Bitwise OR
	|in, not in, is, is not, <, <=, >, >=, !=, ==				|	Comparisons, including membership tests and identity tests
	|not x														|	Boolean NOT
	|and														|	Boolean AND
	|or															|	Conditional expression
	|lambda														|	Lambda expression
	|:=															|	Assignment expression

	#															|- Comment
	''' 														|- Multiline Comment 				
	_block_														|
	'''															|


**PRINTING OUTPUT-- 
	print("& this is Python...")			# new line defaultly. like, end="\n"
	print(end="")							# without new line


**TAKING INPUT--
		variable = input("Enter whatever brother :) ...")


**CONDITIONAL STATEMENT--
	IF		if x < 5:			NESTED IF		if x<5:
				_block_								if x<3:
			elif x == 5:								print("x : ", 4)
				_block_
			else:
				_block_

			resutl = "Even" if n%2==0 else "Odd"

	MATCH	match var:
				case "100":
					_block_
				case "200":
					_block_
				case "300":
					_block_
				case _:
					_block_


**LOOPING(ITERATIVE) STATEMENTS--
	FOR		for x in range(-10,11,2):    //x = -10,-8,...,-2,0,2,...,8,10
				_block_
			else:
				_block_					//will exicute only after last successful iteration of for loop.ie, without 'break'

			list = [x**2 for x in lst]			lst = [1,2,3,4] | list = [1,4,9,16]
			list = [x**2 for x in lst if x > 0]
			
			list = map(function, lst)			//Function can be any operation to perform on every item of lst
					eg. result = list(map(lambda x, y: x + y, n1, n2)) 		# n1=[1,2,3,4] n2=[5,6,7,8] result=[6,8,10,12]
								//map fuction returns the iterator map object, so we need to convert it into the list,tuple,set...

			list = filter(conditioned_function, iterator)			//conditioned_function returns True/False which 
					eg. result = list(filter(lambda x: x%2 != 0, seq))	# seq=[1,2,3,4,5,6] result=[1,3,5]
								//filter function returns iterator filter object, which contains all items for which conditioned_function returns True value 

			for key, val in dict.items():
				_block_

			for index, item in enumerate(list):
				_block_


	WHILE	while x == 5:
				_block_

	RANGE	range(0, 101, 2)	.\>0,2,4,...,98,100.
			range(100, -1, -2)	.\>100,98,...,4,2,0.


**JUMP STATEMENT
	break		# terminates current/working loop and goes out of loop
	continue	# terminates current/working loop and goes for next iteration of loop
	pass		# Used where we don't want any operation to perform


**FUNCTIONS(Modules)--
	func_name():								#Declearing post-defined Function
												argtuple - holds tuple of any no. of arguments values passed while calling the func_name ; must be used before **kargdict
												kargdict - holds dictionary of any no. of keyword arguments values passed while calling the func_name ; must be used as last parameter
	def func_name(par1, par2, *argtuple, **kargdict):	# defining fuction.		parameter = place holder	
		'DocString'										# DocString is the comment about defined function & it's optional
		_block_
		return a, b										# returns all values in the form of tuple eg. (2, 3)	if, a = 2 & b = 3			

	x = func_name(val1, val2,...)				 		# calling function.		argument = actual value  | here, x will be (2, 3)
	
	def func_name(*argtuple):				 
		'DocString'								
		_block_
												

**ANONYMOUS FUNCTIONS--	
	- Functiopn without name
	- Contains no of arguments but only one expression...
	eg.	
		x = lambda a, b: a**b
		print(x(2, 3))					# 8 will be printed


**MODULES--
	We can use py files/modules created in working directory
  examples-
	import module
	import module as obj
	from module import method								method can be Function, Class...
	from module import method as obj
	from module import method1, method2
	from module import *
	
**PACKAGES--
	We can use modules/py files created in sub-folders/packages(collection of sub-packages & modules) of current working directory
  examples-
	import package														> package.module.method()
	import package.module												> module.method()
	import package.sub-package.module									> module.method()
	import package.module as obj										> obj.method()
	from package.module import method_class as obj						> obj()
	from package.sub-package.module import method_class as obj			> obj()

Note -> Modules are defaultly searched in 'sys.path' list of directory by the python compiler
		sys.path list has first item of list is current working directory
	adding directory manually
		in-code		sys.path.append('D:\Anynomus\Documents\Programming\Python\Package\Package1')
		in-cmd		set PYTHONPATH=Sub-package0.sub-package1

**CLASS data type--
	CLASS	class ClassName:
				def __init__(self):								# Constructor function
					_block_
				def function(self):
					_block_
			obj = ClassName()

			eg.

				class Computer:
					def __init__(self):
						self.a											# public variable
						self._b											# protected variable
						self.__c										# private variable

					def config(self):							# 'self' is for individual instance/object we are calling method from...
						print('i5, 16GB, 1TB')

				obj1 = Computer()
				obj2 = Computer()
				Computer.config(obj1)							|
				obj2.config()									| both the ways can be used

**NESTED CLASS--
	CLASS		class ClassName:
					def __init__(self):									# Constructor function
						self.NestedClass = self.NestedClassName()
						print(self.NestedClass.any_nested_class_module())
	NESTED CLASS	class NestedClassName:
						def __init__(self):								# Constructor function
							_block_

				obj = ClassName()
				obj1 = ClassName.NestedClassName()


**INHERITANCE--
	PARENT CLASS	class ClassName:
						def __init__(self):									# Constructor function
							_block_
	CHILD CLASS		class ChildClassName(ClassName):
							def __init__(self):								# Constructor function
								super().__init__(self)						# to access entities of super/parent class
								_block_

				obj = ClassName()
				obj1 = ChildClassName()						#calls constructor of parent class only if, child class doesn't had user defined constructor
																otherwise, defaultly only child class constructor is exicuted


**POLIMORPHISM--
ways to implement polymorphism in python
	-Duck Typing
	-Operator Overloading
	-Method Overloading 	- Method having same name but differnt parameters (implemented using, a = None, b = None & if conditions)
	-Method Overriding  	- Method Overrides the parent method having same name, parameter (I have my parents phone, and I also have my phone)


**FILE HANDLING--
	MODES--
				t				> text file handling mode (Default, if mode is unspecified)
				r / rb			> only able to read content, gives error if file isn't available
				w / wb			> only writing possile. if file exists,erazes old content then write. if file not exist,creates new file then write.
				a / ab			> same as "w". besides, if file already exists, this appends the content after old content of file.
				b				> for working in binary mode

	Creating /				
	overwriting file--	
						fo = open('filename.ext','w')
						fo.write('My name is Ankit')
	
	Reading content 
		from file--
						fi = open('D:\\Anynomus\\Documents\\Programming\\C++\\text.txt', 'r')
						for data in fo:
							print(data)

	Appending to		
		file content--
						fi = open('D:\\Anynomus\\Documents\\Programming\\C++\\text.txt', 'r')
						fo = open('filename.ext','a')
						for data in fi:
							fo.write(data)
					eg. 
						with open("welcome.txt", "r") as fi:
   							data = fi.read()


**EXCEPTION/ERROR ANDLING--
	try:
		_block_
	except error_name as error_msg:				error_name = (ValueError, ...) | defaultly you can leave that as, error_name = Exception
		print(error_msg)							error_msg can be accessed using str(error_msg) in print statement
		_block_
		raise 										raise shows full error msg from the Compiler
	finally:						
		_block_									# Executed in both cases, error as well as no-error